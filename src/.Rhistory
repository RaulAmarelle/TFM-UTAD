dia1=as.Date("2016/07/01",format="%Y/%m/%d")
dia2=as.Date("2016/09/30",format="%Y/%m/%d")
data.period <- seq(dia1, dia2, by=1)
data.period
# No funciona, lo dejo de momento
All.data.period <- df.data
for (i in c(1:nrow(All.data.period))){
if (All.data.period$FECHA[i] %in% data.period){
}else{
All.data.period[i] <- All.data.period[-c(i),]
}
}
# En primer lugar, debemos crear múltiples objetos estacionales con funciones msts.
period <- 1
data_msts <- msts(df.data$KWH, seasonal.periods = c(period, period*7))
# Ahora usamos la función Fourier usando dos condiciones para una cantidad de términos K, en este caso tambien solo 2.
K <- 2
fuur <- fourier(data_msts, K = c(K, K))
# Ahora usamos la función Fourier usando dos condiciones para una cantidad de términos K, en este caso tambien solo 2.
K <- 1
fuur <- fourier(data_msts, K = c(K, K))
# Ahora usamos la función Fourier usando dos condiciones para una cantidad de términos K, en este caso tambien solo 2.
K <- 0.5
fuur <- fourier(data_msts, K = c(K, K))
# En primer lugar, creamos múltiples objetos estacionales con funciones msts.
period <- 1
data_ts <- ts(df.data$KWH, freq = period * 7)
plot(data_ts)
# En primer lugar, calculamos consumo semanal
period <- 1  # una medición diaria
data_ts <- ts(df.data$KWH, freq = period * 7)
plot(data_ts, xlab="Semanal",ylab="% Error")
# En primer lugar, calculamos la tendencia del consumo semanal
period <- 1  # una medición diaria
data_ts <- ts(df.data$KWH, freq = period * 7)
plot(data_ts, xlab="Semanal",ylab="KWH")
decomp_ts <- stl(data_ts, s.window = "periodic", robust = TRUE)$time.series
decomp_ts <- stl(data_ts, s.window = "periodic", robust = TRUE)$time.series
plot(decomp_ts)
trend_part <- ts(decomp_ts[,2])
trend_fit <- auto.arima(trend_part)
trend_for <- forecast(trend_fit, period)$mean
trend_data <- data.table(KWH = c(decomp_ts[,2], trend_for),
Date = c(data.train$FECHA, data.test$FECHA),
Type = c(rep("Real", nrow(data.train)), rep("Forecast",
nrow(data.test))))
install.packages("data.table")
library(readxl)
library(cluster)
library(ggplot2)
library(mclust)
library(fpc)
library(dplyr)
library(stats)
library(lubridate)
library(CausalImpact)
library(data.table)
library(bsts)
library(zoo)
library(rpart) # decision tree method
library(rpart.plot) # tree plot
library(party) # decision tree method
library(forecast) # forecasting methods
#library(ggforce) # visualization tools
#library(plotly) # interactive visualizations
library(grid) # visualizations
library(animation) # gif
trend_data <- data.table(KWH = c(decomp_ts[,2], trend_for),
Date = c(data.train$FECHA, data.test$FECHA),
Type = c(rep("Real", nrow(data.train)), rep("Forecast",
nrow(data.test))))
ggplot(trend_data, aes(Date, KWH, color = Type)) +
geom_line(size = 1.2) +
labs(title = paste(trend_fit)) +
theme_ts
trend_data <- data.table(KWH = c(decomp_ts[,2], trend_for),
Date = c(data.train$FECHA, data.test$FECHA),
Type = c(rep("Real", nrow(data.train)), rep("Forecast",
nrow(data.test))))
ggplot(trend_data, aes(Date, KWH, color = Type)) +
geom_line(size = 0.4) +
labs(title = paste(trend_fit)) +
theme_ts
analisis.ts = ts(df.data$KWH, start = c("2016/03/01"))
analisis.ts = ts(df.data$KWH, start = c("2016/03/01"), frequency = 1)
analisis.ts = ts(df.data$KWH, start = c("2016/03/01"), frequency = 12)
analisis.ts = ts(df.data$KWH, start = c("2016/03/01"), freq = 1)
dia1 = df.data$FECHA[1]
dia1
dia1 = df.data$FECHA[1]
analisis.ts = ts(df.data$KWH, start = dia1, freq = 1)
print(analisis.ts)
boxplot(analisis.ts ~ cycle(analisis.ts))
dia1 = df.data$FECHA[1]
analisis.ts = ts(df.data$KWH, start = dia1, freq = 12)
print(analisis.ts)
dia1 = df.data$FECHA[1]
dia1
dia1 = df.data$FECHA[1]
analisis.ts = ts(df.data$KWH, start = dia1, freq = 12)
print(analisis.ts)
dia1 = df.data$FECHA[1]
analisis.ts = ts(df.data$KWH, start = dia1, freq = 1)
print(analisis.ts)
dia1 = df.data$FECHA[1]
analisis.ts = ts(df.data$KWH, start = dia1, freq = 1)
print(analisis.ts)
View(df.data)
dia1 = df.data$FECHA[1]
dia1
analisis.ts = ts(df.data$KWH, start = dia1, freq = 1)
print(analisis.ts)
dia1 = df.data$FECHA[1]
analisis.ts = ts(df.data$KWH, start = dia1, freq = 1)
print(analisis.ts)
dia1 = df.data$FECHA[1]
dia1
dia1 = df.data$FECHA[1]
analisis.ts = ts(df.data$KWH, start = dia1, freq = 1)
print(analisis.ts)
dia1 <- df.data$FECHA[1]
dia1
dia1 <- df.data$FECHA[1]
analisis.ts = ts(df.data$KWH, start = dia1, freq = 1)
print(analisis.ts)
dia1 <- df.data$FECHA[1]
analisis.ts = ts(df.data$KWH, start = as.Date(dia1), freq = 1)
print(analisis.ts)
dia1 <- as.Date(df.data$FECHA[1], format="%Y/%m/%d")
analisis.ts = ts(df.data$KWH, start = as.Date(dia1), freq = 1)
print(analisis.ts)
dia1 <- as.Date(df.data$FECHA[1], format="%Y/%m/%d")
analisis.ts = ts(df.data$KWH, start = as.Date(dia1), freq = 1)
plot(analisis.ts)
dia1 <- as.Date(df.data$FECHA[1], format="%Y/%m/%d")
analisis.ts = ts(df.data$KWH, start = dia1, freq = 1)
plot(analisis.ts)
dia1 <- df.data$FECHA[1]
analisis.ts = ts(df.data$KWH, start = as.Date(dia1, format="%Y/%m/%d"), freq = 1)
plot(analisis.ts)
dia1 <- as.Date(df.data$FECHA[1], format="%d/%m/%Y")
analisis.ts = ts(df.data$KWH, start = dia1, freq = 1)
plot(analisis.ts)
knitr::opts_chunk$set(echo = TRUE)
dia1 <- as.Date(df.data$FECHA[1], format="%d/%m/%Y")
knitr::opts_chunk$set(echo = TRUE)
library(readxl)
library(cluster)
library(ggplot2)
library(mclust)
library(fpc)
library(dplyr)
library(stats)
library(lubridate)
library(CausalImpact)
library(data.table)
library(bsts)
library(zoo)
library(rpart) # decision tree method
library(rpart.plot) # tree plot
library(party) # decision tree method
library(forecast) # forecasting methods
#library(ggforce) # visualization tools
#library(plotly) # interactive visualizations
library(grid) # visualizations
library(animation) # gif
# Leemos los datos de nuestro data set
data <- read_excel("../dat/DatosSmarkia.xls")
df.data <- as.data.frame(data)
View(df.data)
# Funcion para normalizar datos. El minimo a 0, el maximo a 1
normalize <- function(x){
x <- (x - min(x))/(max(x)-min(x))
return(x)
}
# TRATAMIENTO DE DATOS Y PREANALISIS DEL DATASET
# Tenemos que tratar el dataset, podemos simplificarlo eliminando algunas columnas. La columna 2 se puede eliminar, no aporta nada. De las 3+3 columnas de temperatura, 2+2 son redundantes. Con quedarnos una columna de cada modo de climatizacion, es suficiente. Escogemos CCDD20 y CHDD18, que son las criticas
df.data <- df.data[,-c(2, 5, 6, 9, 10)]
View(df.data)
# Vamos a hacer un preanalisis de variables
dim(df.data)
str(df.data)
summary(df.data)
# Vamos a crear nuevas columnas para dia, mes y anio, nos pueden ser de utilidad para segmentar las predicciones segun periodo. Vamos a procesar las fechas porque estan como cadena de caracteres.
df.data$DAY <- 'NULO'
df.data$MONTH <- 'NULO'
df.data$YEAR <- 'NULO'
for (i in c(1:nrow(df.data))){
my_date <- dmy(df.data$FECHA[i])
df.data$DAY[i] <- day(my_date)
df.data$MONTH[i] <- month(my_date)
df.data$YEAR[i] <- year(my_date)
}
str(df.data)
View(df.data)
# Las nuevas columnas creadas son caracteres. Transformamos valores a numericos. Tambien transformamos la columna fecha de caracteres a clase Date.
df.data$FECHA <- as.Date(df.data$FECHA, format="%d/%m/%Y")
df.data$YEAR <- as.numeric(as.character(df.data$YEAR))
df.data$MONTH <- as.numeric(as.character(df.data$MONTH))
df.data$DAY <- as.numeric(as.character(df.data$DAY))
str(df.data)
View(df.data)
## Puede ser interesante crear una columna categorica Entre semana (ES) y Fin de semana (FS), porque los fines de semana hay previsiblemente mas asistencia
# Primero creamos la variable WeekDay como ('L', 'M', 'X', 'J', 'V', 'S', 'D') segun corresponda
df.data$WEEKDAY <- 'NULO'
seq1 <- c('M', 'X', 'J', 'V', 'S', 'D', 'L')
df.data$WEEKDAY[1:728] <- seq1
df.data$WEEKDAY[729] <- 'M'
# Creamos la variable categorica entre semana (ES) y fin de semana (FS)
df.data$FINDE <- ifelse(df.data$WEEKDAY %in% c('S', 'D'), 'FS', 'ES')
View(df.data)
# Creamos la variable categorica Climatizacion, que tomara 3 valores:
#   - Heating
#   - Cooling
#   - Neutro
df.data$CLIMATIZACION <- ifelse(df.data$CCDD20 > 0, 'Cooling',
ifelse(df.data$CHDD18 > 0, 'Heating', 'Neutro'))
View(df.data)
# Creamos una nueva columna, que la llamaremos ERROR, que sera el % de error de la potencia consumida vs prevision de potencia
df.data$ERROR <- (df.data$KWH-df.data$LB)/df.data$KWH * 100
View(df.data)
# Vamos a calcular los N/A del dataset
nas <- nrow(data[data$CHDD18!=0 & data$CCDD20!=0,])
nas
# Solo hay 4 muestras N/A, aprox el 0.5% de los datos
nas / nrow(df.data) *100
# Considero que puedo eliminar esas filas porque, aparte de ser un numero muy bajo y poco representativo, no se puede saber si ese dia el sistema funciono bajo regimen de calefaccion o refrigeracion, por lo que no podre extraer conclusiones
df.data <- df.data[!is.na(df.data$CCDD20),]
View(df.data)
# Reflejamos la evolucion del error, conviertiendo la variable en una serie temporal
ST_Error=ts(df.data$ERROR,freq=1)
plot(ST_Error,xlab="Jornada",ylab="% Error")
# Vamos a crear variable de datos, para no tener problemas luego con la clase
time.points <- seq(df.data$FECHA[1], df.data$FECHA[725], by = 1)
ST_data <- zoo(df.data$ERROR, time.points)
head(ST_data)
# Para estimar un efecto causal, comenzamos por segmentar dos periodos, uno previo a la intervencion para capacitar el modelo y el segundo periodo, posterior a la intervencion para estimar el cambio.
pre.period <- c(df.data$FECHA[1], df.data$FECHA[456])
post.period <- c(df.data$FECHA[457], df.data$FECHA[725])
impact <- CausalImpact(ST_data, pre.period, post.period)
plot(impact)
summary(impact)
summary(impact, "report")
# Realizamos la division de los datos en dos conjuntos, train y test, siguiendo muestreo aleatorio (80% train, 20% test)
set.seed(1)
ids <- sample(1:nrow(df.data), round(nrow(df.data)*.8))
data.train <- df.data[ids, ]  #80%
data.test <- df.data[-ids, ]  #20%
nrow(data.test)
# Propuesta de tema para las graficas
theme_ts <- theme(panel.border = element_rect(fill = NA,
colour = "grey10"),
panel.background = element_blank(),
panel.grid.minor = element_line(colour = "grey85"),
panel.grid.major = element_line(colour = "grey85"),
panel.grid.major.x = element_line(colour = "grey85"),
axis.text = element_text(size = 13, face = "bold"),
axis.title = element_text(size = 15, face = "bold"),
plot.title = element_text(size = 16, face = "bold"),
strip.text = element_text(size = 16, face = "bold"),
strip.background = element_rect(colour = "black"),
legend.text = element_text(size = 15),
legend.title = element_text(size = 16, face = "bold"),
legend.background = element_rect(fill = "white"),
legend.key = element_rect(fill = "white"))
# La linea LB es la prediccion de consumo
g <- ggplot(df.data, aes(x=FECHA, y=KWH)) +  geom_line() +
geom_line(aes(x=FECHA, y=LB), linetype = 5, color = "red") + geom_smooth(method="lm")
plot(g)
# Para ver un periodo mas en detalle, podemos segmentar los datos
# Ej: del 01/07/2016 al 30/09/2016
dia1=as.Date("2016/07/01",format="%Y/%m/%d")
dia2=as.Date("2016/09/30",format="%Y/%m/%d")
data.period <- seq(dia1, dia2, by=1)
data.period
# NO FUNCIONA, PERO NO AFECTA
All.data.period <- df.data
for (i in c(1:nrow(All.data.period))){
if (All.data.period$FECHA[i] %in% data.period){
}else{
All.data.period[i] <- All.data.period[-c(i),]
}
}
# En primer lugar, calculamos la serie temporal del consumo semanal
period <- 1  # una medicion diaria
data_ts <- ts(df.data$KWH, freq = period * 7)  # medicion semanal
plot(data_ts, xlab="Semanal",ylab="KWH")
decomp_ts <- stl(data_ts, s.window = "periodic", robust = TRUE)$time.series
plot(decomp_ts)
trend_part <- ts(decomp_ts[,2])
trend_fit <- auto.arima(trend_part)
trend_for <- forecast(trend_fit, period)$mean
trend_data <- data.table(KWH = c(decomp_ts[,2], trend_for),
Date = c(data.train$FECHA, data.test$FECHA),
Type = c(rep("Real", nrow(data.train)), rep("Forecast",
nrow(data.test))))
ggplot(trend_data, aes(Date, KWH, color = Type)) +
geom_line(size = 0.4) +
labs(title = paste(trend_fit)) +
theme_ts
dia1
dia.inicio <- as.Date("2016/03/01",format="%Y/%m/%d")
analisis.ts = ts(df.data$KWH, start = dia.inicio, freq = 1)
plot(analisis.ts)
analisis.ts = ts(df.data$KWH, start = df.data$FECHA[1], freq = 1)
plot(analisis.ts)
analisis.ts = ts(df.data$KWH, origin = df.data$FECHA[1], freq = 1)
analisis.ts = ts(df.data$KWH, frequency=1/360, start=c(2011,03,01))
plot(analisis.ts)
analisis.ts = ts(df.data$KWH, frequency=1/360, start=c(2016,03,01))
plot(analisis.ts)
# Leemos los datos de nuestro data set
data <- read_excel("../dat/DatosSmarkia.xls")
df.data <- as.data.frame(data)
View(df.data)
# Funcion para normalizar datos. El minimo a 0, el maximo a 1
normalize <- function(x){
x <- (x - min(x))/(max(x)-min(x))
return(x)
}
# TRATAMIENTO DE DATOS Y PREANALISIS DEL DATASET
# Tenemos que tratar el dataset, podemos simplificarlo eliminando algunas columnas. La columna 2 se puede eliminar, no aporta nada. De las 3+3 columnas de temperatura, 2+2 son redundantes. Con quedarnos una columna de cada modo de climatizacion, es suficiente. Escogemos CCDD20 y CHDD18, que son las criticas
df.data <- df.data[,-c(2, 5, 6, 9, 10)]
View(df.data)
# Vamos a hacer un preanalisis de variables
dim(df.data)
str(df.data)
summary(df.data)
# Vamos a crear nuevas columnas para dia, mes y anio, nos pueden ser de utilidad para segmentar las predicciones segun periodo. Vamos a procesar las fechas porque estan como cadena de caracteres.
df.data$DAY <- 'NULO'
df.data$MONTH <- 'NULO'
df.data$YEAR <- 'NULO'
for (i in c(1:nrow(df.data))){
my_date <- dmy(df.data$FECHA[i])
df.data$DAY[i] <- day(my_date)
df.data$MONTH[i] <- month(my_date)
df.data$YEAR[i] <- year(my_date)
}
str(df.data)
View(df.data)
# Las nuevas columnas creadas son caracteres. Transformamos valores a numericos. Tambien transformamos la columna fecha de caracteres a clase Date.
df.data$FECHA <- as.Date(df.data$FECHA, format="%d/%m/%Y")
df.data$YEAR <- as.numeric(as.character(df.data$YEAR))
df.data$MONTH <- as.numeric(as.character(df.data$MONTH))
df.data$DAY <- as.numeric(as.character(df.data$DAY))
str(df.data)
View(df.data)
## Puede ser interesante crear una columna categorica Entre semana (ES) y Fin de semana (FS), porque los fines de semana hay previsiblemente mas asistencia
# Primero creamos la variable WeekDay como ('L', 'M', 'X', 'J', 'V', 'S', 'D') segun corresponda
df.data$WEEKDAY <- 'NULO'
seq1 <- c('M', 'X', 'J', 'V', 'S', 'D', 'L')
df.data$WEEKDAY[1:728] <- seq1
df.data$WEEKDAY[729] <- 'M'
# Creamos la variable categorica entre semana (ES) y fin de semana (FS)
df.data$FINDE <- ifelse(df.data$WEEKDAY %in% c('S', 'D'), 'FS', 'ES')
View(df.data)
# Creamos la variable categorica Climatizacion, que tomara 3 valores:
#   - Heating
#   - Cooling
#   - Neutro
df.data$CLIMATIZACION <- ifelse(df.data$CCDD20 > 0, 'Cooling',
ifelse(df.data$CHDD18 > 0, 'Heating', 'Neutro'))
View(df.data)
# Creamos una nueva columna, que la llamaremos ERROR, que sera el % de error de la potencia consumida vs prevision de potencia
df.data$ERROR <- (df.data$KWH-df.data$LB)/df.data$KWH * 100
View(df.data)
# Vamos a calcular los N/A del dataset
nas <- nrow(data[data$CHDD18!=0 & data$CCDD20!=0,])
nas
# Solo hay 4 muestras N/A, aprox el 0.5% de los datos
nas / nrow(df.data) *100
# Considero que puedo eliminar esas filas porque, aparte de ser un numero muy bajo y poco representativo, no se puede saber si ese dia el sistema funciono bajo regimen de calefaccion o refrigeracion, por lo que no podre extraer conclusiones
df.data <- df.data[!is.na(df.data$CCDD20),]
View(df.data)
# Reflejamos la evolucion del error, conviertiendo la variable en una serie temporal
ST_Error=ts(df.data$ERROR,freq=1)
plot(ST_Error,xlab="Jornada",ylab="% Error")
# Reflejamos la evolucion del error, conviertiendo la variable en una serie temporal
ST_Error=ts(df.data$ERROR,freq=1)
plot(ST_Error,ylab="% Error")
# Reflejamos la evolucion del error, conviertiendo la variable en una serie temporal
ST_Error=ts(df.data$ERROR,start = df.data$FECHA[1], frequency = 1)
plot(ST_Error,ylab="% Error")
# Reflejamos la evolucion del error, conviertiendo la variable en una serie temporal
ST_Error=ts(df.data$ERROR, start = as.Date(df.data$FECHA[1]), frequency = 1)
plot(ST_Error,ylab="% Error")
# Reflejamos la evolucion del error, conviertiendo la variable en una serie temporal
ST_Error=ts(df.data$ERROR, start = as.POSIXlt(df.data$FECHA[1]), frequency = 1)
# Reflejamos la evolucion del error, conviertiendo la variable en una serie temporal
ST_Error=ts(df.data$ERROR, start = df.data$FECHA[1], frequency = 1)
plot(ST_Error,ylab="% Error")
# Reflejamos la evolucion del error, conviertiendo la variable en una serie temporal
ST_Error=ts(df.data$ERROR, start = format(as.Date(df.data$FECHA[1], origin="1970-01-01")), frequency = 1)
# Reflejamos la evolucion del error, conviertiendo la variable en una serie temporal
ST_Error=ts(df.data$ERROR, start = format(as.Date(df.data$FECHA[1], origin="1970-01-01")), frequency = 1)
# Reflejamos la evolucion del error, conviertiendo la variable en una serie temporal
ST_Error=ts(df.data$ERROR, start = format(as.Date(df.data$FECHA[1], origin="1970-01-01")), frequency = 1)
# Reflejamos la evolucion del error, conviertiendo la variable en una serie temporal
ST_Error=ts(df.data$ERROR, start = df.data$FECHA[1], frequency = 1)
plot(ST_Error,ylab="% Error")
# Vamos a crear variable de datos, para no tener problemas luego con la clase
time.points <- seq(df.data$FECHA[1], df.data$FECHA[725], by = 1)
ST_data <- zoo(df.data$ERROR, time.points)
head(ST_data)
df.data$FECHA[1]
# Reflejamos la evolucion del error, conviertiendo la variable en una serie temporal
ST_Error=ts(df.data$ERROR, start = df.data$FECHA[1], frequency = 1)
plot(ST_Error, ylab="% Error")
# OJO: fecha la transforma en entero y con as.Date sale lo mismo!
# Reflejamos la evolucion del error, conviertiendo la variable en una serie temporal
origin <- df.data$FECHA[1]
ST_Error=ts(df.data$ERROR, start = origin, frequency = 1)
plot(ST_Error, ylab="% Error")
# OJO: Aunque ya es clase Date, la fecha la transforma en entero ??
# Con as.Date sale lo mismo!
# Reflejamos la evolucion del error, conviertiendo la variable en una serie temporal
origin <- df.data$FECHA[1]
unclass(origin)
ST_Error=ts(df.data$ERROR, start = origin, frequency = 1)
plot(ST_Error, ylab="% Error")
# OJO: Aunque ya es clase Date, la fecha la transforma en entero ??
# Con as.Date sale lo mismo!
# Reflejamos la evolucion del error, conviertiendo la variable en una serie temporal
origin <- unclass(df.data$FECHA[1])
ST_Error=ts(df.data$ERROR, start = origin, frequency = 1)
plot(ST_Error, ylab="% Error")
# OJO: Aunque ya es clase Date, la fecha la transforma en entero ??
# Con as.Date sale lo mismo!
# Reflejamos la evolucion del error, conviertiendo la variable en una serie temporal
origin <- format(as.Date(df.data$FECHA[1],origin="1970-01-01"))
ST_Error=ts(df.data$ERROR, start = origin, frequency = 1)
# Reflejamos la evolucion del error, conviertiendo la variable en una serie temporal
origin <- as.Date(df.data$FECHA[1], format="%Y-%m-%d")
ST_Error=ts(df.data$ERROR, start = origin, frequency = 1)
plot(ST_Error, ylab="% Error")
# OJO: Aunque ya es clase Date, la fecha la transforma en entero ??
# Con as.Date sale lo mismo!
# Para estimar un efecto causal, comenzamos por segmentar dos periodos, uno previo a la intervencion para capacitar el modelo y el segundo periodo, posterior a la intervencion para estimar el cambio.
pre.period <- c(df.data$FECHA[1], df.data$FECHA[456])
post.period <- c(df.data$FECHA[457], df.data$FECHA[725])
impact <- CausalImpact(ST_data, pre.period, post.period)
plot(impact)
summary(impact)
summary(impact, "report")
# Realizamos la division de los datos en dos conjuntos, train y test, siguiendo muestreo aleatorio (80% train, 20% test)
set.seed(1)
ids <- sample(1:nrow(df.data), round(nrow(df.data)*.8))
data.train <- df.data[ids, ]  #80%
data.test <- df.data[-ids, ]  #20%
nrow(data.test)
# Propuesta de tema para las graficas
theme_ts <- theme(panel.border = element_rect(fill = NA,
colour = "grey10"),
panel.background = element_blank(),
panel.grid.minor = element_line(colour = "grey85"),
panel.grid.major = element_line(colour = "grey85"),
panel.grid.major.x = element_line(colour = "grey85"),
axis.text = element_text(size = 13, face = "bold"),
axis.title = element_text(size = 15, face = "bold"),
plot.title = element_text(size = 16, face = "bold"),
strip.text = element_text(size = 16, face = "bold"),
strip.background = element_rect(colour = "black"),
legend.text = element_text(size = 15),
legend.title = element_text(size = 16, face = "bold"),
legend.background = element_rect(fill = "white"),
legend.key = element_rect(fill = "white"))
# La linea LB es la prediccion de consumo
g <- ggplot(df.data, aes(x=FECHA, y=KWH)) +  geom_line() +
geom_line(aes(x=FECHA, y=LB), linetype = 5, color = "red") + geom_smooth(method="lm")
plot(g)
# Para ver un periodo mas en detalle, podemos segmentar los datos
# Ej: del 01/07/2016 al 30/09/2016
dia1=as.Date("2016/07/01",format="%Y/%m/%d")
dia2=as.Date("2016/09/30",format="%Y/%m/%d")
data.period <- seq(dia1, dia2, by=1)
data.period
# Reflejamos la evolucion del error, conviertiendo la variable en una serie temporal
origin <- as.Date("01/03/2016", format="%d/%m/%Y")
ST_Error=ts(df.data$ERROR, start = origin, frequency = 1)
plot(ST_Error, ylab="% Error")
# OJO: Aunque ya es clase Date, la fecha la transforma en entero ??
# Con as.Date sale lo mismo!
# En primer lugar, calculamos la serie temporal del consumo semanal
period <- 1  # una medicion diaria
data_ts <- ts(df.data$KWH, freq = period * 7)  # medicion semanal
plot(data_ts, xlab="Semanal",ylab="KWH")
decomp_ts <- stl(data_ts, s.window = "periodic", robust = TRUE)$time.series
plot(decomp_ts)
trend_part <- ts(decomp_ts[,2])
trend_fit <- auto.arima(trend_part)
trend_for <- forecast(trend_fit, period)$mean
trend_data <- data.table(KWH = c(decomp_ts[,2], trend_for),
Date = c(data.train$FECHA, data.test$FECHA),
Type = c(rep("Real", nrow(data.train)), rep("Forecast",
nrow(data.test))))
ggplot(trend_data, aes(Date, KWH, color = Type)) +
geom_line(size = 0.4) +
labs(title = paste(trend_fit)) +
theme_ts
analisis.ts = ts(df.data$KWH, frequency=1/360, start=ymd(c("2016/03/01")))
plot(analisis.ts)
analisis.ts = ts(df.data$KWH, frequency=1, start=df.data$FECHA[1])
plot(analisis.ts)
data.arima <- ts(df.data$KWH, frequency = 1, start = c("01/03/2016"))
data.arima <- ts(df.data$KWH, frequency = 1, start = as.Date(c("01/03/2016")),format="%d/%m/%Y")
data.arima <- ts(df.data$KWH, frequency = 1, start = as.Date(c("01/03/2016"),format="%d/%m/%Y"))
forecast::auto.arima(data.arima)
data.arima <- ts(df.data$KWH, frequency = 1, start = as.Date(c("01/03/2016"),format="%d/%m/%Y"), end = as.Date(c("30/09/2017"),format="%d/%m/%Y"))
forecast::auto.arima(data.arima)
forecast::forecast(forecast::auto.arima(data.arima), h=149)
fcast <- forecast::forecast(forecast::auto.arima(data.arima), h=149)
plot(fcast)
