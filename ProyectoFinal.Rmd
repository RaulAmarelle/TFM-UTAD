---
title: "Proyecto Final"
author: "Raul Amarelle"
date: "7 de agosto de 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

###################
###  LIBRERIAS  ###
###################

```{r}
library(readxl)
library(cluster)
library(ggplot2)
library(mclust)
library(fpc)
library(dplyr)
library(stats)
library(lubridate)
library(CausalImpact)
library(bsts)
library(zoo)
library(rpart) # decision tree method
library(rpart.plot) # tree plot
library(party) # decision tree method
library(forecast) # forecasting methods
#library(ggforce) # visualization tools
#library(plotly) # interactive visualizations
library(grid) # visualizations
library(animation) # gif
```

```{r}
# Leemos los datos de nuestro data set

data <- read_excel("../dat/DatosSmarkia.xls")
df.data <- as.data.frame(data)
View(df.data)
```

```{r}
# Función para normalizar datos. El minimo a 0, el maximo a 1

normalize <- function(x){
  x <- (x - min(x))/(max(x)-min(x))
  return(x)
}
```


############################
###  ANÁLISIS VARIABLES  ###
############################

Este dataset es una recopilación de datos diarios de temperatura y potencia consumida relativos a un centro comercial.

Breve explicación de las variables:
1. Fecha: fecha de la medición, hay una medición diaria
2. Estimado: no sirve de nada
3. Kwh: potencia consumida
4. LB: Línea base, es decir, la predicción de potencia consumida
5 a 10. CCD ó CCHD: Cooling-Degree Day o Cooling Heating Degree Day son temperaturas recogidas en 6 columnas. Es la diferencia entre el promedio diario de temperatura y una determinada temperatura base de referencia (suele ser la exterior). El centro comercial tiene dos modos de climatización: calentar o enfriar, por eso son siempre 3 ceros vs 3 números. 18, 19 y 20 es la temperatura base en ambos casos. Por eso el valor es siempre el mismo sumando o restando 1 de una columna a la siguiente.
11. Afluencia: Número de personas visitantes.


Quiere decir que de las 3+3 columnas de temperatura, 2+2 son redundantes. Con quedarnos una columna de cada modo de climatización, es suficiente. Escogemos CCDD20 y CHDD18.


```{r}
# TRATAMIENTO DE DATOS Y PREANÁLISIS DEL DATASET

# Tenemos que tratar el dataset, podemos simplificarlo eliminando algunas columnas. La columna 2 se puede elimintar, no aporta nada. De las 3+3 columnas de temperatura, 2+2 son redundantes. Con quedarnos una columna de cada modo de climatización, es suficiente. Escogemos CCDD20 y CHDD18, que son las críticas

df.data <- df.data[,-c(2, 5, 6, 9, 10)]
View(df.data)
```

```{r}
# Vamos a hacer un preanálisis de variables

dim(df.data)
str(df.data)
summary(df.data)
```


##########################
###  NUEVAS VARIABLES  ###
##########################

```{r}
# Vamos a crear nuevas columnas para dia, mes y año, nos pueden ser de utilidad para segmentar las predicciones según periodo. Vamos a procesar las fechas porque están como cadena de caracteres.

df.data$DAY <- 'NULO'
df.data$MONTH <- 'NULO'
df.data$YEAR <- 'NULO'

for (i in c(1:nrow(df.data))){
  my_date <- dmy(df.data$FECHA[i])
  df.data$DAY[i] <- day(my_date)
  df.data$MONTH[i] <- month(my_date)
  df.data$YEAR[i] <- year(my_date)
}

str(df.data)
View(df.data)
```


```{r}
# Las nuevas columnas creadas son caracteres. Transformamos valores a numéricos. También transformamos la columna fecha de caracteres a clase Date.

df.data$FECHA <- as.Date(df.data$FECHA, format="%d/%m/%Y")
df.data$YEAR <- as.numeric(as.character(df.data$YEAR))
df.data$MONTH <- as.numeric(as.character(df.data$MONTH))
df.data$DAY <- as.numeric(as.character(df.data$DAY))

str(df.data)
View(df.data)
```

```{r}
## Puede ser interesante añadir crear una columna categórica entre semana (ES) y fin de semana (FS), porque los fines de semana hay previsiblemente más asistencia

# Primero creamos la variable WeekDay como ('L', 'M', 'X', 'J', 'V', 'S', 'D') según corresponda
df.data$WEEKDAY <- 'NULO'

seq1 <- c('M', 'X', 'J', 'V', 'S', 'D', 'L')
df.data$WEEKDAY[1:728] <- seq1
df.data$WEEKDAY[729] <- 'M'

# Creamos la variable categórica entre semana (ES) y fin de semana (FS)
df.data$FINDE <- ifelse(df.data$WEEKDAY %in% c('S', 'D'), 'FS', 'ES')

View(df.data)
```

```{r}
# Creamos la variable categórica Climatización, que tomará 3 valores:
#   - Heating
#   - Cooling
#   - Neutro
df.data$CLIMATIZACION <- ifelse(df.data$CCDD20 > 0, 'Cooling',
                                         ifelse(df.data$CHDD18 > 0, 'Heating', 'Neutro'))

View(df.data)
```


```{r}
# Creamos una nueva columna, que la llamaremos ERROR, que será el % de error de la potencia consumida vs previsión de potencia
df.data$ERROR <- (df.data$KWH-df.data$LB)/df.data$KWH * 100

View(df.data)
```


########################
###  MISSING VALUES  ###
########################

```{r}
# Vamos a calcular los N/A del dataset
nas <- nrow(data[data$CHDD18!=0 & data$CCDD20!=0,])
nas

# Sólo hay 4 muestras N/A, aprox el 0.5% de los datos
nas / nrow(df.data) *100

# Considero que puedo eliminar esas filas porque, aparte de ser un número muy bajo y poco representativo, no se puede saber si ese día el sistema funcionó bajo régimen de calefacción o refrigeración, por lo que no podré extraer conclusiones
df.data <- df.data[!is.na(df.data$CCDD20),]

View(df.data)
```


################################
###  DISTRIBUCIÓN VARIABLES  ###
################################

## VAMOS A CONGELAR ESTA PARTE, HASTA QUE TENGAMOS UN POCO MÁS CLARO QUÉ BUSCAR
Parece razonable observar: 
La distribución de las variables (las escalamos para observar mejor de forma conjunta la distribución de todas)
Ya que estamos trabajando con una serie temporal, ver la evolución que toman las variables

```{r}
# Distribución con funciones de densidad
ggplot() +
  geom_density(data = df.data, aes(x = scale(KWH), colour = 'kWh')) +
  geom_density(data = df.data, aes(x = scale(LB), colour = 'LB')) +
  geom_density(data = df.data, aes(x = scale(CCDD20), colour = 'CCDD20')) +
  geom_density(data = df.data, aes(x = scale(CHDD18), colour = 'CHDD18')) + 
  geom_density(data = df.data, aes(x = scale(AFLUENCIA), colour = 'AFLUENCIA')) + 
  scale_colour_manual('', breaks = c('KWH', 'LB', 'CCDD20', 'CHDD18', 'AFLUENCIA'), values = c('red', 'blue', 'black', 'yellow', 'green'))
```

```{r}
# Serie temporal
SerieTemporal <- 1:nrow(df.data)

ggplot(data = df.data) +
  geom_line(aes(x = SerieTemporal, y = normalize(KWH), colour = 'KWH')) +
  geom_line(aes(x = SerieTemporal, y = normalize(LB), colour = 'LB')) + 
  geom_line(aes(x = SerieTemporal, y = normalize(CCDD20), colour = 'CCDD20')) + 
  geom_line(aes(x = SerieTemporal, y = normalize(CHDD18), colour = 'CHDD18')) +
  geom_line(aes(x = SerieTemporal, y = normalize(AFLUENCIA), colour = 'AFLUENCIA')) + 
  scale_colour_manual('', breaks = c('KWH', 'LB', 'CCDD20', 'CHDD18', 'AFLUENCIA'), values = c('red', 'blue', 'black', 'yellow', 'green'))

```

```{r}
# Muy complicado apreciar nada. Parece razonable pensar que dentro de un mismo año la serie sigue más o menos la misma distribución. Vemos la distribución de la serie para 2017
SerieTemporal2 <- seq(1,364)

ggplot(data = df.data[df.data$YEAR == '2017',]) +
  geom_line(aes(x = SerieTemporal2, y = normalize(KWH), color = 'KWH')) +
  geom_line(aes(x = SerieTemporal2, y = normalize(LB), color = 'LB')) + 
  geom_line(aes(x = SerieTemporal2, y = normalize(CCDD20), color = 'CCDD20')) + 
  geom_line(aes(x = SerieTemporal2, y = normalize(CHDD18), color = 'CHDD18')) +
  geom_line(aes(x = SerieTemporal2, y = normalize(AFLUENCIA), color = 'AFLUENCIA')) + 
  scale_colour_manual('', breaks = c('KWH', 'LB', 'CCDD20', 'CHDD18', 'AFLUENCIA'), values = c('red', 'blue', 'black', 'yellow', 'green'))
```


```{r}
# Vamos a comparar solo la serie temporal de KWH (real) y LB(predicción)
ggplot(data = df.data) + 
  geom_line(aes(x = SerieTemporal, y = KWH, color = 'KWH')) +
  geom_line(aes(x = SerieTemporal, y = LB, color = 'LB')) + 
  scale_colour_manual('', breaks = c('KWH', 'LB'), values = c('red', 'blue'))
```

```{r}
# Vemos el diagrama de barras de la variable Climatizacion
ggplot(data = df.data, aes(x = CLIMATIZACION)) + geom_bar(aes(fill = CLIMATIZACION))
```


```{r}
# AFLUENCIA agrupada por día de la semanas
# suma
aggregate(formula = AFLUENCIA ~ WEEKDAY, data = df.data, FUN = sum)
# media
aggregate(formula = AFLUENCIA ~ WEEKDAY, data = df.data, FUN = mean)

# AFLUENCIA agrupada por mes
# media
aggregate(formula = AFLUENCIA ~ MONTH, data = df.data, FUN = mean)
```

```{r}
# POTENCIA (kWh)
# agrupada por fin de semana/dia de la semana
aggregate(formula = KWH ~ FINDE, data = df.data, FUN = mean)
# agrupada por meses
aggregate(formula = KWH ~ MONTH, data = df.data, FUN = mean)
```


```{r}
## CORRELACIONES ##
# Vamos a ver la matriz de correlaciones entre KWH (2), CCDD20(4), CHDD18(5) y AFLUENCIA (6)

correlation <- cor(df.data[,c(2,4,5,6)])
correlation
```


################################
###  ANÁLISIS CAUSAL IMPACT  ###
################################

Causal Impact using Bayesian Structural Time-Series Models

```{r}
# Reflejamos la evolución error, conviertiendo la variable en una serie temporal
ST_Error=ts(df.data$ERROR,freq=1)
plot(ST_Error,xlab="Jornada",ylab="% Error")

```

Como primera aproximación, podemos observar que el modelo de predicción ha mejorado a partir de la muestra 450 aprox, ya que el % Error es mucho menor, tiende a concentrarse en la horquilla de -10% a +10%.

Vamos a suponer que a partir de la medición 458, coincidiendo con el 01/06/2017, se han introducido mejoras en el algoritmo de predicción.

```{r}
# Vamos a crear variable de datos, para no tener problemas luego con la clase
time.points <- seq(df.data$FECHA[1], df.data$FECHA[725], by = 1)
ST_data <- zoo(df.data$ERROR, time.points)
head(ST_data)
```


```{r}
# Para estimar un efecto causal, comenzamos por segmentar dos periodos, uno previo a la intervención para capacitar el modelo y el segundo periodo, posterior a la intervención para estimar el cambio.

pre.period <- c(df.data$FECHA[1], df.data$FECHA[456])
post.period <- c(df.data$FECHA[457], df.data$FECHA[725])
#post.period <- c("2017-06-01", "2018-02-27")
head(pre.period)

```

```{r}
impact <- CausalImpact(ST_data, pre.period, post.period)
plot(impact)
```

```{r}
summary(impact)
```

```{r}
summary(impact, "report")
```


#################################
###  TIME SERIES FORECASTING  ###
#################################

Using regression trees for forecasting

```{r}
# Realizamos la división de los datos en dos conjuntos, train y test, siguiendo muestreo aleatorio (80% train, 20% test)
set.seed(1)
ids <- sample(1:nrow(df.data), round(nrow(df.data)*.8))
data.train <- df.data[ids, ]  #80%
data.test <- df.data[-ids, ]  #20%
nrow(data.test)
```

```{r}
theme_ts <- theme(panel.border = element_rect(fill = NA, 
                                              colour = "grey10"),
                  panel.background = element_blank(),
                  panel.grid.minor = element_line(colour = "grey85"),
                  panel.grid.major = element_line(colour = "grey85"),
                  panel.grid.major.x = element_line(colour = "grey85"),
                  axis.text = element_text(size = 13, face = "bold"),
                  axis.title = element_text(size = 15, face = "bold"),
                  plot.title = element_text(size = 16, face = "bold"),
                  strip.text = element_text(size = 16, face = "bold"),
                  strip.background = element_rect(colour = "black"),
                  legend.text = element_text(size = 15),
                  legend.title = element_text(size = 16, face = "bold"),
                  legend.background = element_rect(fill = "white"),
                  legend.key = element_rect(fill = "white"))
```

```{r}
# La línea LB es la predicción de consumo
g <- ggplot(df.data, aes(x=FECHA, y=KWH)) +  geom_line() + 
  geom_line(aes(x=FECHA, y=LB), linetype = 5, color = "red") + geom_smooth(method="lm")
plot(g)

```

```{r}
# Para ver un periodo más en detalle, podemos segmentar los datos
# Ej: del 01/07/2016 al 30/09/2016

dia1=as.Date("2016/07/01",format="%Y/%m/%d")
dia2=as.Date("2016/09/30",format="%Y/%m/%d")
data.period <- seq(dia1, dia2, by=1)
data.period

```

```{r}
# No funciona, lo dejo de momento

All.data.period <- df.data

for (i in c(1:nrow(All.data.period))){
  if (All.data.period$FECHA[i] %in% data.period){
    
  }else{
    All.data.period[i] <- All.data.period[-c(i),]
  }
    
}

View(All.data.period)

```

```{r}
g <- ggplot(All.data.period, aes(x=FECHA, y=KWH)) +  geom_line() + 
  geom_line(aes(x=FECHA, y=LB), linetype = 5, color = "red") + geom_smooth(method="lm")
plot(g)
```


```{r}

```

```{r}

```






