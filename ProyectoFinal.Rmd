---
title: "Proyecto Final"
author: "Raul Amarelle"
date: "7 de agosto de 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

###################
###  LIBRERIAS  ###
###################

```{r}
library(readxl)
library(cluster)
library(ggplot2)
library(mclust)
library(fpc)
library(dplyr)
library(stats)
library(lubridate)
library(CausalImpact)
library(bsts)
library(zoo)
library(rpart) # decision tree method
library(rpart.plot) # tree plot
library(party) # decision tree method
library(forecast) # forecasting methods
#library(ggforce) # visualization tools
#library(plotly) # interactive visualizations
library(grid) # visualizations
library(animation) # gif
```

```{r}
# Leemos los datos de nuestro data set

data <- read_excel("../dat/DatosSmarkia.xls")
df.data <- as.data.frame(data)
View(df.data)
```

```{r}
# Funcion para normalizar datos. El minimo a 0, el maximo a 1

normalize <- function(x){
  x <- (x - min(x))/(max(x)-min(x))
  return(x)
}
```


############################
###  ANALISIS VARIABLES  ###
############################

Este dataset es una recopilacion de datos diarios de temperatura y potencia consumida relativos a un centro comercial.

Breve explicacion de las variables:
1. Fecha: fecha de la medicion, hay una medicion diaria
2. Estimado: no sirve de nada
3. Kwh: potencia consumida
4. LB: Linea base, es decir, la prediccion de potencia consumida
5 a 10. CCD o CCHD: Cooling-Degree Day o Cooling Heating Degree Day son temperaturas recogidas en 6 columnas. Es la diferencia entre el promedio diario de temperatura y una determinada temperatura base de referencia (suele ser la exterior). El centro comercial tiene dos modos de climatizacion: calentar o enfriar, por eso son siempre 3 ceros vs 3 numeros. 18, 19 y 20 es la temperatura base en ambos casos. Por eso el valor es siempre el mismo sumando o restando 1 de una columna a la siguiente.
11. Afluencia: Numero de personas visitantes.


Quiere decir que de las 3+3 columnas de temperatura, 2+2 son redundantes. Con quedarnos una columna de cada modo de climatizacion, es suficiente. Escogemos CCDD20 y CHDD18.


```{r}
# TRATAMIENTO DE DATOS Y PREANALISIS DEL DATASET

# Tenemos que tratar el dataset, podemos simplificarlo eliminando algunas columnas. La columna 2 se puede elimintar, no aporta nada. De las 3+3 columnas de temperatura, 2+2 son redundantes. Con quedarnos una columna de cada modo de climatizacion, es suficiente. Escogemos CCDD20 y CHDD18, que son las criticas

df.data <- df.data[,-c(2, 5, 6, 9, 10)]
View(df.data)
```

```{r}
# Vamos a hacer un preanalisis de variables

dim(df.data)
str(df.data)
summary(df.data)
```


##########################
###  NUEVAS VARIABLES  ###
##########################

```{r}
# Vamos a crear nuevas columnas para dia, mes y año, nos pueden ser de utilidad para segmentar las predicciones segun periodo. Vamos a procesar las fechas porque estan como cadena de caracteres.

df.data$DAY <- 'NULO'
df.data$MONTH <- 'NULO'
df.data$YEAR <- 'NULO'

for (i in c(1:nrow(df.data))){
  my_date <- dmy(df.data$FECHA[i])
  df.data$DAY[i] <- day(my_date)
  df.data$MONTH[i] <- month(my_date)
  df.data$YEAR[i] <- year(my_date)
}

str(df.data)
View(df.data)
```


```{r}
# Las nuevas columnas creadas son caracteres. Transformamos valores a numericos. Tambien transformamos la columna fecha de caracteres a clase Date.

df.data$FECHA <- as.Date(df.data$FECHA, format="%d/%m/%Y")
df.data$YEAR <- as.numeric(as.character(df.data$YEAR))
df.data$MONTH <- as.numeric(as.character(df.data$MONTH))
df.data$DAY <- as.numeric(as.character(df.data$DAY))

str(df.data)
View(df.data)
```

```{r}
## Puede ser interesante añadir crear una columna categorica entre semana (ES) y fin de semana (FS), porque los fines de semana hay previsiblemente mas asistencia

# Primero creamos la variable WeekDay como ('L', 'M', 'X', 'J', 'V', 'S', 'D') segun corresponda
df.data$WEEKDAY <- 'NULO'

seq1 <- c('M', 'X', 'J', 'V', 'S', 'D', 'L')
df.data$WEEKDAY[1:728] <- seq1
df.data$WEEKDAY[729] <- 'M'

# Creamos la variable categorica entre semana (ES) y fin de semana (FS)
df.data$FINDE <- ifelse(df.data$WEEKDAY %in% c('S', 'D'), 'FS', 'ES')

View(df.data)
```

```{r}
# Creamos la variable categorica Climatizacion, que tomara 3 valores:
#   - Heating
#   - Cooling
#   - Neutro
df.data$CLIMATIZACION <- ifelse(df.data$CCDD20 > 0, 'Cooling',
                                         ifelse(df.data$CHDD18 > 0, 'Heating', 'Neutro'))

View(df.data)
```


```{r}
# Creamos una nueva columna, que la llamaremos ERROR, que sera el % de error de la potencia consumida vs prevision de potencia
df.data$ERROR <- (df.data$KWH-df.data$LB)/df.data$KWH * 100

View(df.data)
```


########################
###  MISSING VALUES  ###
########################

```{r}
# Vamos a calcular los N/A del dataset
nas <- nrow(data[data$CHDD18!=0 & data$CCDD20!=0,])
nas

# Solo hay 4 muestras N/A, aprox el 0.5% de los datos
nas / nrow(df.data) *100

# Considero que puedo eliminar esas filas porque, aparte de ser un numero muy bajo y poco representativo, no se puede saber si ese dia el sistema funciono bajo regimen de calefaccion o refrigeracion, por lo que no podre extraer conclusiones
df.data <- df.data[!is.na(df.data$CCDD20),]

View(df.data)
```


################################
###  DISTRIBUCION VARIABLES  ###
################################

## VAMOS A CONGELAR ESTA PARTE, HASTA QUE TENGAMOS UN POCO MÁS CLARO QUE BUSCAR
Parece razonable observar: 
La distribucion de las variables (las escalamos para observar mejor de forma conjunta la distribucion de todas)
Ya que estamos trabajando con una serie temporal, ver la evolucion que toman las variables

```{r}
# Distribucion con funciones de densidad
ggplot() +
  geom_density(data = df.data, aes(x = scale(KWH), colour = 'kWh')) +
  geom_density(data = df.data, aes(x = scale(LB), colour = 'LB')) +
  geom_density(data = df.data, aes(x = scale(CCDD20), colour = 'CCDD20')) +
  geom_density(data = df.data, aes(x = scale(CHDD18), colour = 'CHDD18')) + 
  geom_density(data = df.data, aes(x = scale(AFLUENCIA), colour = 'AFLUENCIA')) + 
  scale_colour_manual('', breaks = c('KWH', 'LB', 'CCDD20', 'CHDD18', 'AFLUENCIA'), values = c('red', 'blue', 'black', 'yellow', 'green'))
```

```{r}
# Serie temporal
SerieTemporal <- 1:nrow(df.data)

ggplot(data = df.data) +
  geom_line(aes(x = SerieTemporal, y = normalize(KWH), colour = 'KWH')) +
  geom_line(aes(x = SerieTemporal, y = normalize(LB), colour = 'LB')) + 
  geom_line(aes(x = SerieTemporal, y = normalize(CCDD20), colour = 'CCDD20')) + 
  geom_line(aes(x = SerieTemporal, y = normalize(CHDD18), colour = 'CHDD18')) +
  geom_line(aes(x = SerieTemporal, y = normalize(AFLUENCIA), colour = 'AFLUENCIA')) + 
  scale_colour_manual('', breaks = c('KWH', 'LB', 'CCDD20', 'CHDD18', 'AFLUENCIA'), values = c('red', 'blue', 'black', 'yellow', 'green'))

```

```{r}
# Muy complicado apreciar nada. Parece razonable pensar que dentro de un mismo año la serie sigue mas o menos la misma distribucion. Vemos la distribución de la serie para 2017
SerieTemporal2 <- seq(1,364)

ggplot(data = df.data[df.data$YEAR == '2017',]) +
  geom_line(aes(x = SerieTemporal2, y = normalize(KWH), color = 'KWH')) +
  geom_line(aes(x = SerieTemporal2, y = normalize(LB), color = 'LB')) + 
  geom_line(aes(x = SerieTemporal2, y = normalize(CCDD20), color = 'CCDD20')) + 
  geom_line(aes(x = SerieTemporal2, y = normalize(CHDD18), color = 'CHDD18')) +
  geom_line(aes(x = SerieTemporal2, y = normalize(AFLUENCIA), color = 'AFLUENCIA')) + 
  scale_colour_manual('', breaks = c('KWH', 'LB', 'CCDD20', 'CHDD18', 'AFLUENCIA'), values = c('red', 'blue', 'black', 'yellow', 'green'))
```


```{r}
# Vamos a comparar solo la serie temporal de KWH (real) y LB(prediccion)
ggplot(data = df.data) + 
  geom_line(aes(x = SerieTemporal, y = KWH, color = 'KWH')) +
  geom_line(aes(x = SerieTemporal, y = LB, color = 'LB')) + 
  scale_colour_manual('', breaks = c('KWH', 'LB'), values = c('red', 'blue'))
```

```{r}
# Vemos el diagrama de barras de la variable Climatizacion
ggplot(data = df.data, aes(x = CLIMATIZACION)) + geom_bar(aes(fill = CLIMATIZACION))
```


```{r}
# AFLUENCIA agrupada por día de la semanas
# suma
aggregate(formula = AFLUENCIA ~ WEEKDAY, data = df.data, FUN = sum)
# media
aggregate(formula = AFLUENCIA ~ WEEKDAY, data = df.data, FUN = mean)

# AFLUENCIA agrupada por mes
# media
aggregate(formula = AFLUENCIA ~ MONTH, data = df.data, FUN = mean)
```

```{r}
# POTENCIA (kWh)
# agrupada por fin de semana/dia de la semana
aggregate(formula = KWH ~ FINDE, data = df.data, FUN = mean)
# agrupada por meses
aggregate(formula = KWH ~ MONTH, data = df.data, FUN = mean)
```


```{r}
## CORRELACIONES ##
# Vamos a ver la matriz de correlaciones entre KWH (2), CCDD20(4), CHDD18(5) y AFLUENCIA (6)

correlation <- cor(df.data[,c(2,4,5,6)])
correlation
```


################################
###  ANALISIS CAUSAL IMPACT  ###
################################

Causal Impact using Bayesian Structural Time-Series Models

```{r}
# Reflejamos la evolución error, conviertiendo la variable en una serie temporal
ST_Error=ts(df.data$ERROR,freq=1)
plot(ST_Error,xlab="Jornada",ylab="% Error")

```

Como primera aproximacion, podemos observar que el modelo de prediccion ha mejorado a partir de la muestra 450 aprox, ya que el % Error es mucho menor, tiende a concentrarse en la horquilla de -10% a +10%.

Vamos a suponer que a partir de la medicion 458, coincidiendo con el 01/06/2017, se han introducido mejoras en el algoritmo de prediccion.

```{r}
# Vamos a crear variable de datos, para no tener problemas luego con la clase
time.points <- seq(df.data$FECHA[1], df.data$FECHA[725], by = 1)
ST_data <- zoo(df.data$ERROR, time.points)
head(ST_data)
```


```{r}
# Para estimar un efecto causal, comenzamos por segmentar dos periodos, uno previo a la intervencion para capacitar el modelo y el segundo periodo, posterior a la intervencion para estimar el cambio.

pre.period <- c(df.data$FECHA[1], df.data$FECHA[456])
post.period <- c(df.data$FECHA[457], df.data$FECHA[725])
#post.period <- c("2017-06-01", "2018-02-27")
head(pre.period)

```

```{r}
impact <- CausalImpact(ST_data, pre.period, post.period)
plot(impact)
```

```{r}
summary(impact)
```

```{r}
summary(impact, "report")
```


#################################
###  TIME SERIES FORECASTING  ###
#################################

Using regression trees for forecasting

```{r}
# Realizamos la division de los datos en dos conjuntos, train y test, siguiendo muestreo aleatorio (80% train, 20% test)
set.seed(1)
ids <- sample(1:nrow(df.data), round(nrow(df.data)*.8))
data.train <- df.data[ids, ]  #80%
data.test <- df.data[-ids, ]  #20%
nrow(data.test)
```

```{r}
theme_ts <- theme(panel.border = element_rect(fill = NA, 
                                              colour = "grey10"),
                  panel.background = element_blank(),
                  panel.grid.minor = element_line(colour = "grey85"),
                  panel.grid.major = element_line(colour = "grey85"),
                  panel.grid.major.x = element_line(colour = "grey85"),
                  axis.text = element_text(size = 13, face = "bold"),
                  axis.title = element_text(size = 15, face = "bold"),
                  plot.title = element_text(size = 16, face = "bold"),
                  strip.text = element_text(size = 16, face = "bold"),
                  strip.background = element_rect(colour = "black"),
                  legend.text = element_text(size = 15),
                  legend.title = element_text(size = 16, face = "bold"),
                  legend.background = element_rect(fill = "white"),
                  legend.key = element_rect(fill = "white"))
```

```{r}
# La linea LB es la prediccion de consumo
g <- ggplot(df.data, aes(x=FECHA, y=KWH)) +  geom_line() + 
  geom_line(aes(x=FECHA, y=LB), linetype = 5, color = "red") + geom_smooth(method="lm")
plot(g)

```

```{r}
# Para ver un periodo mas en detalle, podemos segmentar los datos
# Ej: del 01/07/2016 al 30/09/2016

dia1=as.Date("2016/07/01",format="%Y/%m/%d")
dia2=as.Date("2016/09/30",format="%Y/%m/%d")
data.period <- seq(dia1, dia2, by=1)
data.period

```

```{r}
# No funciona, lo dejo de momento

All.data.period <- df.data

for (i in c(1:nrow(All.data.period))){
  if (All.data.period$FECHA[i] %in% data.period){
    
  }else{
    All.data.period[i] <- All.data.period[-c(i),]
  }
    
}

View(All.data.period)

```

```{r}
g <- ggplot(All.data.period, aes(x=FECHA, y=KWH)) +  geom_line() + 
  geom_line(aes(x=FECHA, y=LB), linetype = 5, color = "red") + geom_smooth(method="lm")
plot(g)
```


```{r}

```

```{r}

```






